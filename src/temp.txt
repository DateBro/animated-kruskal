    public void sort(){
        System.out.println("sort start");
        while (true) {
            try {
                Thread.sleep(100);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //检测返回flag
            if (stopFlag){
                stopFlag=false; //重置返回标志
                canGoFlag = false; //重置开始标志
                break;
            }
            if (canGoFlag) {    //canGo为true，开始排序

                Queue<WeightedLabeledEdge> mst = new Queue<>();
                MinPQ<WeightedLabeledEdge> pq = new MinPQ<>();
                for (WeightedLabeledEdge e : graphicsEdgeWeightedGraph.edges())
                    pq.insert(e);
                UF uf = new UF(graphicsEdgeWeightedGraph.V());
                codes[0].setColor(Code.BLACK);
                codes[1].setColor(Code.BLACK);
                algoBufferShow();

                while (!pq.isEmpty()) {
                    //检测各个标志
                    if (stopFlag){
                        break;
                    }
                    if (resetFlag){
                        break;
                    }

                    WeightedLabeledEdge e = pq.delMin();
                    NumberLabeledVertex labeledV = e.eitherLabeledVertex(), labeledW = e.otherLabeledVertex(labeledV);
                    int v = labeledV.getValue();
                    int w = labeledW.getValue();

                    labeledV.setBorderColor(NumberLabeledVertex.YELLOW_2);
                    labeledW.setBorderColor(NumberLabeledVertex.YELLOW_2);
                    setSingleCodeColor(codes, 2, Code.BLACK, Code.GLASS_GREEN);
                    algoBufferShow();
                    checkPause();
                    if (resetFlag) {
                        resetFlag = false;
                        return;
                    }

                    if (!uf.connected(v, w)) {
                        uf.union(v, w);
                        setSingleCodeColor(codes, 3, Code.BLACK, Code.GLASS_GREEN);
                        labeledV.setBorderColor(NumberLabeledVertex.RED);
                        labeledW.setBorderColor(NumberLabeledVertex.RED);
                        algoBufferShow();
                        checkPause();
                        if (resetFlag) {
                            resetFlag = false;
                            return;
                        }

                        mst.enqueue(e);
                        e.setGraphicsColor(WeightedLabeledEdge.RED);
                        setSingleCodeColor(codes, 4, Code.BLACK, Code.GLASS_GREEN);
                        algoBufferShow();
                        checkPause();
                        if (resetFlag) {
                            resetFlag = false;
                            return;
                        }
                    } else {
                        setSingleCodeColor(codes, 5, Code.BLACK, Code.GLASS_GREEN);
                        e.setGraphicsColor(WeightedLabeledEdge.GRAY);
                        labeledV.setBorderColor(NumberLabeledVertex.RED);
                        labeledW.setBorderColor(NumberLabeledVertex.RED);
                        algoBufferShow();
                        checkPause();
                        if (resetFlag) {
                            resetFlag = false;
                            return;
                        }
                    }
                }

                setSingleCodeColor(codes, 6, Code.BLACK, Code.GLASS_GREEN);
                algoBufferShow();
                checkPause();
                startOrPauseButton.setText("End");
                canGoFlag = false;

                for (int i = N; i > 0; i--) {
                    //检测各个标志
                    if (stopFlag){
                        break;
                    }
                    if (resetFlag){
                        break;
                    }
                    for (int j = 0; j < i - 1; j++) {
                        //检测各个标志
                        if (stopFlag){
                            break;
                        }
                        if (resetFlag){
                            break;
                        }
                        arr[j].setColor(Bar.BLUE);
                        arr[j + 1].setColor(Bar.BLUE);
                        codes[2].setColor(Code.BLACK);
                        hint.setStr("比较相邻元素大小");
                        //设置暂停点
                        if(pauseFlag){
                            while (pauseFlag){
                                try {
                                    Thread.sleep(300);
                                } catch (InterruptedException e) {
                                    e.printStackTrace();
                                }
                                if(stopFlag||resetFlag)break;
                            }
                        }
                        try {
                            Thread.sleep(speed);
                        } catch (InterruptedException e) {
                            e.printStackTrace();
                        }
                        codes[2].setColor(Code.GLASS_GREEN);

                        if (resetFlag){
                            break;
                        }
                        if (j + 1 == i - 1) {
                            arr[j + 1].setColor(Bar.GREEN);
                        }
                        else {
                            arr[j + 1].setColor(Bar.YELLOW);

                        }
                        arr[j].setColor(Bar.YELLOW);
                        codes[3].setColor(Code.GLASS_GREEN);
                    }
                }
                if (stopFlag){
                    stopFlag=false;
                    canGoFlag = false;
                    break;
                }
                if (resetFlag){
                    resetFlag=false;
                    canGoFlag = false;
                    for(int i=0;i<N;i++) {
                        a[i] = a2[i];
                        arr[i]=new Bar(60*i+150,600-a[i]*3,50,a[i]*3,a[i]);
                    }

                }
                canGoFlag = false;
            }
            if (resetFlag){ //初始化
                resetFlag=false;
                canGoFlag = false;
                for(int i=0;i<N;i++) {
                    a[i] = a2[i];
                    arr[i]=new Bar(60*i+150,600-a[i]*3,50,a[i]*3,a[i]);
                }

            }

        }

        System.out.println("sort end");
    }
